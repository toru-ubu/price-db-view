<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>価格推移DB - 一覧</title>
<style>
body { font-family: sans-serif; }
input[type="text"], select { padding: 8px; font-size: 16px; margin: 12px 8px 12px 0; }
label { font-size: 16px; margin-right: 8px; }
.table-container { overflow-x: auto; width: 100%; }
table { border-collapse: collapse; width: 100%; min-width: 900px; }
th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
th.sortable::after {
  content: " ▲▼";
  font-size: 10px;
  color: #ccc;
}
th.sorted-asc::after,
th.sorted-desc::after {
  content: " ▲▼";
  font-size: 10px;
  color: #000;
  font-weight: bold;
}
th.sortable:hover { background-color: #e2e2e2; cursor: pointer; }
th { background-color: #f2f2f2; }
a { color: #1a0dab; text-decoration: none; }
.favorite-btn { cursor: pointer; font-size: 18px; }
.favorite-true { color: gold; }
@media (max-width: 768px) { table { font-size: 14px; } th, td { padding: 4px; } }
</style>
</head>
<body>

<h1>価格推移DB（2025-06-26 時点）</h1>

<input type="text" id="searchBox" placeholder="商品名・CPU・GPUなどで検索...">
<label><input type="checkbox" id="favoriteOnly"> お気に入りのみ表示</label>
<label>
  形状フィルター:
  <select id="formFilter">
    <option value="all">すべて</option>
    <option value="notebook">ノートパソコン</option>
    <option value="desktop">デスクトップ</option>
    <option value="portable">ポータブルゲーミングPC</option>
  </select>
</label>

<div class="table-container">
<table id="productTable">
<thead>
<tr>
<th></th>
<th>商品名</th>
<th class="sortable">通常価格</th>
<th class="sortable">現在価格</th>
<th class="sortable">ポイント還元</th>
<th class="sortable">実質価格</th>
<th class="sortable">割引率</th>
<th>買い時？</th>
<th>CPU</th>
<th>GPU</th>
<th>メモリ</th>
<th>ストレージ</th>
</tr>
</thead>
<tbody>

<tr>
  ...
  <td data-value="0.0">0.0%</td>
  ...
</tr>

<tr>
  ...
  <td data-value="0.0">0.0%</td>
  ...
</tr>

<tr>
  ...
  <td data-value="0.0">0.0%</td>
  ...
</tr>

</tbody>
</table>
</div>

<script>
const searchBox = document.getElementById("searchBox");
const favoriteOnly = document.getElementById("favoriteOnly");
const formFilter = document.getElementById("formFilter");
const table = document.getElementById("productTable");
const favoriteSet = new Set(JSON.parse(localStorage.getItem("favorites") || "[]"));

function updateFavorites() {
  document.querySelectorAll(".favorite-btn").forEach(btn => {
    const url = btn.dataset.url;
    btn.textContent = favoriteSet.has(url) ? "★" : "☆";
    btn.classList.toggle("favorite-true", favoriteSet.has(url));
  });
}

function filterRows() {
  const keyword = searchBox.value.toLowerCase();
  const form = formFilter.value;
  document.querySelectorAll("tbody tr").forEach(row => {
    const url = row.dataset.url;
    const text = (row.dataset.name + row.dataset.cpu + row.dataset.gpu).toLowerCase();
    const formFactor = row.dataset.form;
    const matchSearch = text.includes(keyword);
    const matchFavorite = !favoriteOnly.checked || favoriteSet.has(url);
    const matchForm = (form === "all") || (formFactor === form);
    row.style.display = matchSearch && matchFavorite && matchForm ? "" : "none";
  });
}

searchBox.addEventListener("input", filterRows);
favoriteOnly.addEventListener("change", filterRows);
formFilter.addEventListener("change", filterRows);

document.addEventListener("click", e => {
  if (e.target.classList.contains("favorite-btn")) {
    const url = e.target.dataset.url;
    if (favoriteSet.has(url)) favoriteSet.delete(url);
    else favoriteSet.add(url);
    localStorage.setItem("favorites", JSON.stringify([...favoriteSet]));
    updateFavorites();
    filterRows();
  }
});

updateFavorites();
filterRows();



document.querySelectorAll("th.sortable").forEach((header, i) => {
  header.addEventListener("click", () => {
    const tbody = table.querySelector("tbody");
    const rows = Array.from(tbody.querySelectorAll("tr"));
    const isAsc = header.classList.contains("sorted-asc");

    // クラス初期化
    document.querySelectorAll("th").forEach(th => th.classList.remove("sorted-asc", "sorted-desc"));
    header.classList.add(isAsc ? "sorted-desc" : "sorted-asc");

    // ソート対象列を取得
    const colIndex = Array.from(header.parentNode.children).indexOf(header);

    rows.sort((a, b) => {
      const cellA = a.children[colIndex];
      const cellB = b.children[colIndex];
      const valA = parseFloat(cellA.dataset.value || "0");
      const valB = parseFloat(cellB.dataset.value || "0");
      return isAsc ? valB - valA : valA - valB;
    });

    rows.forEach(row => tbody.appendChild(row));
  });
});
</script>

</body>
</html>
